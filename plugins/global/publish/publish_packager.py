
import os
import pyblish.api
from reveries import utils


class CollectPublishPackager(pyblish.api.InstancePlugin):
    """
    """

    label = "Publish Packager"
    order = pyblish.api.CollectorOrder + 0.49999999

    def process(self, instance):
        instance.data["packager"] = PublishPackager(instance)


class PublishPackager(object):

    def __init__(self, instance):

        if "packages" not in instance.data:
            instance.data["packages"] = dict()  # representations' data
        if "files" not in instance.data:
            instance.data["files"] = list()
        if "hardlinks" not in instance.data:
            instance.data["hardlinks"] = list()

        self._data = instance.data

        self._representation = None
        self._skip_stage = False

    def __repr__(self):
        return "PublishPackager()"

    def create_package(self, with_representation=True):
        """Create representation stage dir

        Register and create a staging directory for extraction usage later on.

        MUST call this in every representation's extraction process.

        The default staging directory is generated by `tempfile.mkdtemp()` with
        "pyblish_tmp_" prefix, but if the extraction method get decorated with
        `skip_stage`, the staging directory will be the publish directory.

        Args:
            with_representation (bool): Whether to append representation dir to
                                        the end of the staging path.
                                        Default True.

        Return:
            pkg_dir (str): staging directory

        """
        staging_dir = self._data.get("stagingDir", None)

        if not staging_dir:
            if self._skip_stage:
                staging_dir = self._data["versionDir"]
            else:
                staging_dir = utils.temp_dir(prefix="pyblish_tmp_")

            self._data["stagingDir"] = staging_dir

        if with_representation:
            pkg_dir = os.path.join(staging_dir, self._representation)
        else:
            pkg_dir = staging_dir

        versioner = self._data["versioner"]
        repr_dir = versioner.representation_dir(self._representation)

        self.add_data({
            "packageDir": pkg_dir,
            "representationDir": repr_dir,
        })
        os.makedirs(pkg_dir, exist_ok=True)
        # Reset
        self._skip_stage = False

        return pkg_dir

    def set_representation(self, representation):
        self._representation = representation

    def skip_stage(self):
        """Make extractor directly save to publish dir

        This will make `create_package()` return representation's
        versioned dir in publish space.

        And the `instance.data["stagingDir"]` will be set to versioned dir
        instead of random dir in temp folder. So there should be no file/dir
        copy while intergation since the representation already exists in
        final destination.

        """
        self._skip_stage = True

    def file_name(self, extension="", suffix=""):
        """Convenient method for composing file name with default format"""
        extension = ("." + extension) if extension else ""
        return "{subset}{suffix}{ext}".format(subset=self._data["subset"],
                                              suffix=suffix,
                                              ext=extension)

    def add_data(self, data):
        """Add(Update) data to representation

        Arguments:
            data (dict): Additional representation data

        """
        if self._representation not in self._data["packages"]:
            self._data["packages"][self._representation] = dict()

        package_data = self._data["packages"][self._representation]
        utils.deep_update(package_data, data)

    def add_file(self, src, dst):
        """Add file to copy queue

        Arguments:
            src (str): Source file path
            dst (str): The path that file needs to be copied to

        """
        self._data["files"].append((src, dst))

    def add_hardlink(self, src, dst):
        """Add file to hardlink queue

        Arguments:
            src (str): Source file path
            dst (str): The path that file needs to be hardlinked to

        """
        self._data["hardlinks"].append((src, dst))
